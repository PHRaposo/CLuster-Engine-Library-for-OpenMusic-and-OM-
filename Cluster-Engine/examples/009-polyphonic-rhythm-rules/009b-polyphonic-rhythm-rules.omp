; OM File Header - Saved 2021/07/23 1:55:33
; (6.18 :patc (om-make-point 10 60) (om-make-point 49 50) (om-make-point 1154 484) "" 183 0 "2021/07/09 23:44:04" "2021/07/19 22:01:48")
; End File Header
(in-package :om)(load-lib-for (quote ("Cluster-Engine")))(setf *om-current-persistent* (om-load-patch1 "009b-polyphonic-rhythm-rules" (quote ((let ((box (om-load-boxcall (quote genfun) "RULES-TO-CLUSTER" (quote cluster-engine::rules-to-cluster) (quote ((om-load-inputfun (quote input-funbox) "rules" "RULES?" nil))) (om-make-point 4350/7 3644/21) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "CLUSTER-ENGINE" (quote cluster-engine::cluster-engine) (quote ((om-load-inputfun (quote input-funbox) "integer" "NO-OF-VARIABLES" 10) (om-load-inputfun (quote input-funbox) "t/nil" "RND?" (quote t)) (om-load-inputfun (quote input-funbox) "t/nil" "DEBUG?" nil) (om-load-inputfun (quote input-funbox) "t/nil" "RULES" nil) (om-load-inputfun (quote input-funbox) "number" "TEMPO" 90) (om-load-inputfunmenu1 (quote input-funmenu) "voices-or-list" "OUTPUT" (quote :voices) (list (list "voices" (quote :voices)) (list "list" (quote :list)))) (om-load-inputfun (quote input-funbox) "list-of-timsig" "METRIC-DOMAIN" (list (list 4 4))) (om-load-inputfun (quote input-funbox) "ratios" "RHYTHMDOMAIN0" (list (list 1/4))) (om-load-inputfun (quote input-funbox) "midics" "PITCHDOMAIN0" (list (list 7200))) (om-load-inputfun (quote input-funbox) "ratios" "RHYTHMDOMAIN1" nil) (om-load-inputfun (quote input-funbox) "midics" "PITCHDOMAIN1" (list (list 6700))))) (om-make-point 4735/7 5618/21) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 5015/7 3539/21) (om-make-point 202 30) (list (list 1/2) (list 1/4) (list 1/8) (list 1/16) (list -1/4)) "((1/2) (1/4) (1/8) (1/16) (-1/4))" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "patch" (om-load-patch-abs1 "patch" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 274 431) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 399 303) (om-make-point 24 30) (quote t) "t" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 76 346) (om-make-point 445 57) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NOT" (quote not) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 287 271) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMAND" (quote omand) (quote ((om-load-inputfun (quote input-funbox) "something" "SELF" nil) (om-load-inputfun (quote input-funbox) "other things" "REST" nil))) (om-make-point 292 224) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 130 127) (om-make-point 27 30) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 103 160) (om-make-point 35 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "PLUSP 2" (quote plusp) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 335 153) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "PLUSP" (quote plusp) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 238 152) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 282 0) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 94 73) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 338 72) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 243 72) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 0 0 nil 0) (6 0 2 0 nil 1) (3 0 2 1 nil 0) (1 0 2 2 nil 0) (4 0 3 0 nil 0) (8 0 4 0 nil 2) (7 0 4 1 nil 3) (10 0 6 0 nil 1) (5 0 6 1 nil 0) (11 0 7 0 nil 3) (12 0 8 0 nil 2) (9 0 10 0 nil 1) (9 0 11 0 nil 3) (9 0 12 0 nil 2))) 6.18 nil "" (om-make-point 193 165) (om-make-point 664 504)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 3608/7 125/7) nil (list nil) "l" "patch"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 3993/7 279/7) (om-make-point 87 30) (quote :d1_offs_d2) ":d1_offs_d2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "RRHYTHM-RHYTHM" (quote cluster-engine::rrhythm-rhythm) (quote ((om-load-inputfun (quote input-funbox) "rule" "RULE" nil) (om-load-inputfun (quote input-funbox) "voice1" "VOICE1" 0) (om-load-inputfun (quote input-funbox) "voice2" "VOICE2" 1) (om-load-inputfunmenu1 (quote input-funmenu) "input-mode1" "INPUT-MODE1" (quote :d1_offs_d2) (list (list "d1_offs" (quote :d1_offs)) (list "d1_offs_d2" (quote :d1_offs_d2)))) (om-load-inputfunmenu1 (quote input-funmenu) "input-mode2" "INPUT-MODE2" (quote :norm) (list (list "norm" (quote :norm)) (list "list" (quote :list)))) (om-load-inputfunmenu1 (quote input-funmenu) "input-filter" "INPUT-FILTER" (quote :at-durations-v1) (list (list "at-durations-v1" (quote :at-durations-v1)) (list "at-events-v1" (quote :at-events-v1)) (list "break-at-rest-v1" (quote :break-at-rest-v1)) (list "break-at-rest-v1-v2" (quote :break-at-rest-v1-v2)))))) (om-make-point 3895/7 650/7) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "POLY" (quote poly) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "list of VOICE objects" "voices" (list (let ((newobj (when (find-class (quote voice) nil) (make-instance (quote voice) :tree (quote (1 (((4 4) (1 1 1 1))))) :chords (load-obj-list-from-save (quote ((let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord)))) :tempo (quote ((1/4 60) nil)) :legato 100 :ties (quote (nil nil nil nil)))))) (load-port-info newobj (quote nil)) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj))))) (om-make-point 538 357) (om-make-point 415 150) (if (find-class (quote poly) nil) (let ((newobj (make-instance (quote poly) :voices (list (let ((newobj (when (find-class (quote voice) nil) (make-instance (quote voice) :tree (quote (3 (((4 4) (1 (1 (1 1 2)) 1 1)) ((4 4) (1.0 (1 (1 1)) (1 (1.0 1)) (1 (1.0 -1)))) ((4 4) ((1 (-1 -1)) -3))))) :chords (load-obj-list-from-save (quote ((let ((thechord (make-instance (quote chord) :lmidic (quote (7200)) :ldur (quote (667)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7200)) :ldur (quote (167)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7200)) :ldur (quote (167)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7200)) :ldur (quote (333)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7200)) :ldur (quote (667)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7200)) :ldur (quote (667)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7200)) :ldur (quote (333)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7200)) :ldur (quote (333)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7200)) :ldur (quote (333)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord)))) :tempo (quote ((1/4 90) nil)) :legato 100 :ties (quote (nil nil nil nil nil nil nil nil nil)))))) (load-port-info newobj (quote nil)) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote voice) nil) (make-instance (quote voice) :tree (quote (3 (((4 4) (-4)) ((4 4) (1 -1 (1 (1 3)) 1.0)) ((4 4) ((1 (1.0 3)) 1.0 (1 (1.0 -3)) -1))))) :chords (load-obj-list-from-save (quote ((let ((thechord (make-instance (quote chord) :lmidic (quote (6700)) :ldur (quote (667)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6700)) :ldur (quote (167)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6700)) :ldur (quote (500)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6700)) :ldur (quote (500)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord)))) :tempo (quote ((1/4 90) nil)) :legato 100 :ties (quote (nil nil nil nil)))))) (load-port-info newobj (quote nil)) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj)) :from-file t))) (load-port-info newobj (quote (nil nil))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj)) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode cursor-mode show-stems scale)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (2 2 2))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil nil (quote :osc-scoreplayer) 1 nil 1000 0 (om-make-point 370 280) (om-make-point 400 20) 0 1 (quote :normal) (quote t) nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 405 470) (quote "POLYPHONIC RHYTHM RULES 2$$The rrhythm-rhythm accesses durations in two voices. It passes the information about the length of the durations and how they are positioned relative to each other (i.e. if their onset is simultaneous, or if there is an offset between them). This information is chosen in the first menu in the fourth input  (never pass more information than the internal patch need, since that will make the search less efficient).$$The menu in the sixth input sets the time points for where the rule is checked: either it is only checked at notes in the first voice (:at-durations-v1), or it is checked at notes AND rests (:at-events-v1). Note that even if the rule is only checked at notes, it might find simultaneous rests in the other voice (rests will be indicated as negative fractions).$$In the example patch, the rule is checked at the onset of each note in the first voice. The information that is passed to the internal patch has the format '(duration-voice1 offset duration-voice2). The offset is the duration between the onset for the duration in the first voice and the onset for the duration in the second voice (a negative offset means that the event in the second voice starts before the event in the first voice).$$The rule restricts onsets in the two voices to never be simultaneous (open the internal patch to see how it is done). Note that there is a risk that the solution contains many rests to satisfy the constraint.") "" (om-make-point 11 31) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((5 0 0 0 nil 0) (0 0 1 3 nil 0) (2 0 1 7 nil 0) (2 0 1 9 nil 0) (3 0 5 0 nil 0) (4 0 5 3 nil 0) (1 0 6 1 nil 0))) nil 6.18))
